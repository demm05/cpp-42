#include <iostream>
#include <vector>
#include <list>
#include <iterator>
#include <algorithm>

// --- 1. The "Fast" Path (Vector) ---
// Triggered when the iterator is Random Access
template <typename Iterator>
void makePairsImpl(Iterator begin, Iterator end, size_t pair_size,
                   std::random_access_iterator_tag) {
    std::cout << "[C++98] Optimized Random Access Path (Direct Math)"
              << std::endl;

    // Your original logic using std::advance is fine here because advance is
    // O(1) or you can use direct indexing: begin[i]
}

// --- 2. The "Buffered" Path (List) ---
// Triggered when the iterator is Bidirectional (like std::list)
template <typename Iterator>
void makePairsImpl(Iterator begin, Iterator end, size_t pair_size,
                   std::bidirectional_iterator_tag) {
    std::cout << "[C++98] Slow Iterator Path (Using Buffer)" << std::endl;

    // A. Create the Shadow Vector of Iterators
    std::vector<Iterator> buffer;
    // In C++98, reserve is good practice
    // buffer.reserve(std::distance(begin, end));

    for (Iterator it = begin; it != end; ++it) {
        buffer.push_back(it);
    }

    // B. Now you have random access to the iterators via buffer[i]
    // You can run your sorting logic on 'buffer' (which is a vector)
    // Example: Accessing the middle element instantly
    size_t   mid_idx = buffer.size() / 2;
    Iterator middle_iter = buffer[mid_idx];

    std::cout << "Middle value accessed instantly: " << *middle_iter
              << std::endl;

    // C. (Optional) If you swapped things in the buffer,
    // you would use .splice() here to fix the real list.
}

// --- 3. The Public Dispatcher ---
template <typename Container>
void makePairs(Container& c, size_t pair_size) {
    // This is the C++98 magic.
    // We extract the category tag from the iterator.
    typedef typename std::iterator_traits<
        typename Container::iterator>::iterator_category Category;

    // We instantiate the tag "Category()" and pass it as a dummy argument.
    // The compiler selects the matching function above at compile time.
    makePairsImpl(c.begin(), c.end(), pair_size, Category());
}

int main() {
    // std::vector<int> v;
    // v.push_back(10);
    // v.push_back(20);
    // v.push_back(30);

    std::list<int> l;
    l.push_back(10);
    l.push_back(20);
    l.push_back(30);

    // // Will print: [C++98] Optimized Random Access Path
    // makePairs(v, 1);

    // Will print: [C++98] Slow Iterator Path (Using Buffer)
    makePairs(l, 1);

    return 0;
}
